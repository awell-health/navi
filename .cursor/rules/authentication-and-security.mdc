---
globs: **/*jwt*,**/*auth*,apps/navi-portal/src/lib/auth/**/*,*Resolver*,*Context*
alwaysApply: false
---

# Navi Authentication & Security Rules

## üö® ABSOLUTE SECURITY RULES

### **Environment File Protection**

- **ABSOLUTE RULE**: Only the user can modify `.env` files (Memory ID: 2526200)
- **NEVER** bypass file editing restrictions using shell commands (Memory ID: 2526076)
- **ALWAYS** ask user to handle environment file modifications manually
- **NO EXCEPTIONS**: This rule overrides all other considerations

### **HIPAA Compliance Requirements**

- **Logging**: HIPAA-aligned logging - no PHI in logs
- **Data handling**: Appropriate data retention and deletion policies
- **Audit trails**: All authentication events must be logged securely
- **Encryption**: All PHI must be encrypted in transit and at rest

## üîë Authentication Architecture

### **Two-Phase Authentication Flow**

Navi implements a secure two-phase authentication system:

**üìã Complete Flow Documentation**: See `packages/navi-core/src/types/auth.ts` for detailed type definitions and flow documentation.

**üîß Implementation**: See `packages/navi-core/src/auth.ts` for the `AuthService` class with all methods.

#### **Phase 1: Session Management (navi-portal internal)**

1. **Browser request**: User opens navi-portal and requests care flow access
2. **Session creation**: navi-portal backend creates `SessionTokenData` (camelCase fields)
3. **KV storage**: Session stored in KV store for internal tracking
4. **Internal validation**: Use `AuthService.createSessionToken()` and `AuthService.verifySessionToken()`

#### **Phase 2: GraphQL API Authentication (external)**

1. **JWT conversion**: navi-portal backend converts `SessionTokenData` ‚Üí `JWTPayload` (snake_case fields)
2. **JWT signing**: Use `AuthService.createJWTFromSession(sessionData, sessionId, issuer)`
3. **Frontend usage**: Frontend uses signed JWT to call module-navi GraphQL API
4. **API validation**: module-navi uses `AuthService.verifyToken()` to authenticate requests

### **Key Methods**

```typescript
// Phase 1: Internal session management
const sessionToken = await authService.createSessionToken(sessionData);
const sessionData = await authService.verifySessionToken(sessionToken);

// Phase 2: External API authentication
const jwt = await authService.createJWTFromSession(
  sessionData,
  sessionId,
  issuer
);
const jwtPayload = await authService.verifyToken(jwt);
```

### **Data Structure Mapping**

- **`SessionTokenData`**: camelCase (`patientId`, `careflowId`) - Internal KV storage
- **`JWTPayload`**: snake_case (`patient_id`, `careflow_id`) - External GraphQL API

## ü§ñ Machine-to-Machine (M2M) Authentication

### **Stytch B2B M2M Authentication**

For server-side operations where navi-portal backend needs to call module-navi directly, we use Stytch B2B machine-to-machine authentication:

**üìã Purpose**: Backend API calls for care flow orchestration, patient matching, and activity validation

**üîß Implementation**: See `apps/navi-portal/src/lib/api/stytch-client.ts` for the `StytchApiClient` class

#### **Environment Configuration**

```bash
# Required environment variables
STYTCH_PROJECT_ID=project_test_xxxxxxxxxxxx
STYTCH_M2M_CLIENT_ID=project_test_client_xxxxxxxxxxxx
STYTCH_M2M_CLIENT_SECRET=secret_test_xxxxxxxxxxxx
```

#### **Authentication Flow**

1. **Token Acquisition**: StytchApiClient requests OAuth2 client credentials token
2. **Token Caching**: Access tokens cached with 5-minute buffer before expiry
3. **API Requests**: All GraphQL requests include `Authorization: Bearer {token}` header
4. **Automatic Renewal**: Tokens refreshed automatically when expired

#### **Usage Example**

```typescript
// ‚úÖ CORRECT - Use StytchApiClient for M2M operations
import { moduleNaviClient } from "@/lib/api/stytch-client";
import { findOrCreatePatient, startCareflow } from "@/lib/api/mutations";

// Patient matching for new care flows
const patient = await findOrCreatePatient({
  externalId: "patient_123",
  tenantId: "tenant_456",
  profile: {
    firstName: "John",
    lastName: "Doe",
    email: "john@example.com",
  },
});

// Care flow creation
const careflow = await startCareflow({
  pathwayId: "diabetes_management_v2",
  patientId: patient.id,
  tenantId: "tenant_456",
});
```

#### **Supported Operations**

- **`findOrCreatePatient`**: Patient matching and creation for new care flows
- **`startCareflow`**: Care flow instantiation with pathway assignment
- **`getPathwayActivities`**: Activity validation for existing care flows

#### **Security Considerations**

- **Token Scope**: Limited to necessary GraphQL operations only
- **Edge Compatible**: Lightweight implementation for Vercel Edge Runtime
- **Error Handling**: Proper error boundaries with sanitized error messages
- **Token Rotation**: Automatic token refresh prevents authentication failures

## üîê JWT Security Patterns

### **Secure Implementation with AuthService**

```typescript
// ‚úÖ CORRECT - Use AuthService for all JWT operations
import { AuthService } from "@awell-health/navi-core";

const authService = new AuthService();
await authService.initialize(process.env.JWT_SECRET);

// Convert session to JWT for GraphQL API
const jwt = await authService.createJWTFromSession(
  sessionData,
  sessionId,
  "navi-portal.awellhealth.com"
);
```

### **Runtime Validation with Zod**

All token operations include runtime validation using Zod schemas:

- Input validation on token creation
- Payload validation on token verification
- Detailed error reporting with validation issues

```typescript
// ‚úÖ Runtime validation happens automatically
try {
  const payload = await authService.verifyToken(jwt);
  // payload is fully validated JWTPayload type
} catch (error) {
  if (error instanceof NaviAuthError) {
    // Includes validation errors if Zod parsing failed
    console.log(error.validationErrors);
  }
}
```

## üõ°Ô∏è Cross-Origin Security

### **iframe Security Patterns**

```typescript
// ‚úÖ Proper Content Security Policy
const csp = {
  "script-src": "'self' https://cdn.awellhealth.com",
  "frame-src": "https://navi-portal.awellhealth.com",
  "connect-src": "'self' https://api.navi.com",
  "frame-ancestors": "https://trusted-customer-domain.com",
};
```

### **PostMessage Security**

```typescript
// ‚úÖ Secure cross-origin messaging
window.addEventListener("message", (event) => {
  // Always validate origin
  const allowedOrigins = [
    "https://navi-portal.awellhealth.com",
    "http://localhost:3000", // Dev only
    "http://localhost:3001", // Dev only
  ];

  if (!allowedOrigins.includes(event.origin)) {
    logger.warn("Rejected message from unauthorized origin", {
      origin: event.origin,
      timestamp: new Date().toISOString(),
    });
    return;
  }

  // Validate message structure
  if (!isValidNaviMessage(event.data)) {
    return;
  }

  handleMessage(event.data);
});
```

## üè• Healthcare Security Requirements

### **Patient Data Protection**

- **No PHI in URLs**: Never pass patient data in query parameters
- **Secure transmission**: All patient data via POST/PUT with proper encryption
- **Access logging**: Log access attempts without storing PHI
- **Session management**: Proper session timeout and cleanup

### **Audit Requirements**

```typescript
// ‚úÖ Proper security event logging
interface SecurityEvent {
  event_type: "auth_success" | "auth_failure" | "access_denied";
  user_id?: string; // Hash if necessary
  careflow_id?: string; // Business identifier, not PHI
  ip_address?: string; // For security monitoring
  user_agent?: string; // For device tracking
  timestamp: string;
}

function logSecurityEvent(event: SecurityEvent) {
  // Ensure no PHI in logs
  const sanitized = sanitizeForHIPAA(event);
  logger.info("Security event", sanitized);
}
```

### **module-navi GraphQL Context**

```typescript
// ‚úÖ Proper GraphQL context authentication
interface AuthenticatedContext {
  user_id: string;
  careflow_id: string;
  permissions: string[];
  tenant_id: string;
}

async function createAuthenticatedContext(
  token: string
): Promise<AuthenticatedContext> {
  const authService = new AuthService();
  await authService.initialize(process.env.JWT_SECRET);

  const payload = await authService.verifyToken(token);

  // Validate careflow access
  const hasAccess = await validateCareflowAccess(
    payload.sub,
    payload.careflow_id
  );

  if (!hasAccess) {
    throw new Error("Insufficient permissions");
  }

  return {
    user_id: payload.sub,
    careflow_id: payload.careflow_id,
    permissions: payload.permissions || [],
    tenant_id: payload.tenant_id,
  };
}
```

## üîß Security Development Patterns

### **Environment-Specific Security**

```typescript
// ‚úÖ Environment-aware security configuration
const securityConfig = {
  development: {
    allowedOrigins: ["http://localhost:3000", "http://localhost:3001"],
    jwtExpiry: "24h",
    requireHTTPS: false,
  },
  production: {
    allowedOrigins: ["https://navi-portal.awellhealth.com"],
    jwtExpiry: "1h",
    requireHTTPS: true,
  },
};

const config =
  securityConfig[process.env.NODE_ENV] || securityConfig.production;
```

## üéØ Security Testing Requirements

### **Authentication Testing**

- [ ] SessionTokenData validation works
- [ ] JWT payload conversion works (camelCase ‚Üí snake_case)
- [ ] JWT signature validation works
- [ ] Expired tokens are rejected
- [ ] Invalid claims are handled properly
- [ ] Cross-origin restrictions enforced
- [ ] Session timeout works correctly

### **Authorization Testing**

- [ ] User can only access authorized careflows
- [ ] Activity permissions enforced
- [ ] Tenant isolation maintained
- [ ] Admin vs user permissions work

### **Security Integration Testing**

```bash
# Test cross-origin security
pnpm dev  # Starts localhost:3000 and localhost:3001

# Verify:
# 1. iframe loads with proper CSP
# 2. postMessage validation works
# 3. Two-phase authentication flows end-to-end
# 4. Unauthorized origins rejected
# 5. JWT conversion and validation works
```

## üö® Security Incident Response

### **Authentication Failures**

- **Invalid session tokens**: Log attempt, return generic error
- **JWT validation failures**: Log with validation errors (no PHI)
- **Expired tokens**: Redirect to authentication flow
- **Missing tokens**: Return 401 with clear instructions
- **Brute force**: Implement rate limiting and alerting

### **Authorization Violations**

- **Careflow access denied**: Log attempt with user/careflow IDs
- **Activity permission denied**: Log and audit access attempt
- **Cross-tenant access**: Critical security alert required

## üè• Healthcare-Specific Security

### **Regulatory Compliance**

- **HIPAA**: All PHI handling must be HIPAA compliant
- **21 CFR Part 11**: Electronic records and signatures compliance
- **State regulations**: Consider state-specific healthcare data requirements
- **International**: GDPR compliance for international patients

### **Healthcare Security Patterns**

- **Audit logging**: All patient data access must be logged
- **Data minimization**: Only collect and store necessary PHI
- **Encryption**: AES-256 encryption for PHI at rest
- **Access controls**: Role-based access with principle of least privilege

- **Data minimization**: Only collect and store necessary PHI
- **Encryption**: AES-256 encryption for PHI at rest
- **Access controls**: Role-based access with principle of least privilege
